import { z } from 'zod';

/**
 * Actor types representing who performed an action
 */
export const ActorTypeSchema = z.enum([
  'user',           // End user (traveler)
  'agent',          // Travel agent
  'admin',          // Platform administrator
  'system',         // Automated system process
  'service',        // Internal service
]);

export type ActorType = z.infer<typeof ActorTypeSchema>;

/**
 * Actor information - who performed the action
 * Required for every audit event per constitution rules
 */
export const ActorSchema = z.object({
  type: ActorTypeSchema,
  id: z.string().uuid(),
  email: z.string().email().optional(),
  displayName: z.string().optional(),
  ipAddress: z.string().ip().optional(),
  userAgent: z.string().optional(),
  serviceId: z.string().optional(), // For service-to-service calls
});

export type Actor = z.infer<typeof ActorSchema>;

/**
 * Resource being acted upon
 */
export const ResourceSchema = z.object({
  type: z.string().min(1).max(100), // e.g., 'booking', 'itinerary', 'user', 'agent'
  id: z.string().min(1).max(255),
  parentType: z.string().optional(),
  parentId: z.string().optional(),
});

export type Resource = z.infer<typeof ResourceSchema>;

/**
 * State change tracking
 * Captures before/after state for complete traceability
 */
export const StateChangeSchema = z.object({
  before: z.record(z.unknown()).nullable(),
  after: z.record(z.unknown()).nullable(),
  changedFields: z.array(z.string()).optional(),
});

export type StateChange = z.infer<typeof StateChangeSchema>;

/**
 * Event severity levels for filtering and alerting
 */
export const SeveritySchema = z.enum([
  'debug',
  'info',
  'warning',
  'error',
  'critical',
]);

export type Severity = z.infer<typeof SeveritySchema>;

/**
 * Domain event categories for the platform
 */
export const EventCategorySchema = z.enum([
  'booking',
  'itinerary',
  'payment',
  'refund',
  'dispute',
  'user',
  'agent',
  'chat',
  'admin',
  'auth',
  'system',
]);

export type EventCategory = z.infer<typeof EventCategorySchema>;

/**
 * Complete audit event schema
 * Immutable record of every state change in the platform
 */
export const AuditEventSchema = z.object({
  // Event identification
  id: z.string().uuid(),
  correlationId: z.string().uuid(), // Links related events across services
  causationId: z.string().uuid().optional(), // ID of event that caused this event
  
  // Event metadata
  eventType: z.string().min(1).max(255), // e.g., 'booking.created', 'payment.completed'
  eventVersion: z.string().default('1.0'),
  category: EventCategorySchema,
  severity: SeveritySchema.default('info'),
  
  // Timestamp (immutable, set at creation)
  timestamp: z.string().datetime(),
  
  // Actor information (REQUIRED - per constitution)
  actor: ActorSchema,
  
  // What was affected
  resource: ResourceSchema,
  
  // Action details
  action: z.string().min(1).max(255), // e.g., 'create', 'update', 'delete', 'view'
  reason: z.string().min(1).max(2000), // REQUIRED - why was this action taken
  
  // State tracking (REQUIRED for mutations)
  stateChange: StateChangeSchema.optional(),
  
  // Additional context
  metadata: z.record(z.unknown()).optional(),
  
  // Source information
  source: z.object({
    service: z.string().min(1),
    version: z.string().optional(),
    environment: z.string().optional(),
  }),
  
  // Legal/compliance fields
  gdprRelevant: z.boolean().default(false),
  piiContained: z.boolean().default(false),
  retentionCategory: z.enum(['standard', 'legal', 'financial', 'extended']).default('standard'),
});

export type AuditEvent = z.infer<typeof AuditEventSchema>;

/**
 * Schema for creating a new audit event (input)
 * ID and timestamp are generated by the service
 */
export const CreateAuditEventSchema = AuditEventSchema.omit({
  id: true,
  timestamp: true,
});

export type CreateAuditEvent = z.infer<typeof CreateAuditEventSchema>;

/**
 * Stored audit record with database fields
 */
export const StoredAuditEventSchema = AuditEventSchema.extend({
  // Database-specific fields
  sequenceNumber: z.number().int().positive(),
  storedAt: z.string().datetime(),
  checksum: z.string(), // Integrity verification
});

export type StoredAuditEvent = z.infer<typeof StoredAuditEventSchema>;
